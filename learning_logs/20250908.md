```python
class Student:
    def __init__(self, name, student_id):
        self._name: name
        self._student_id = student_id
        # 성적을 저장하기 윈한 빈 딕셔너리 과목명 key, 점수 value
        self._grades = {}

```

1. Java version의 setter/ getter 를 생성했습니다.
   - Java에서는 access modifier 개념이 있었기 때문에 field를 private로 선언했다면 setter / getter 는 필수적입니다.
   - 문제는 python에서는 access modifier라고 할만한 개념이 없기 때문에 모든 객체의 속성이 외부로 노출됩니다.
2. 이상을 이유로 python에서는 `_속성명` 이라고 명시하게 되면, '내부적으로만 사용하라고 권장되는 변수'라고 개발자들끼리 약속한 개념에 가깝습니다.
3. name vs. _name
   - name
     - 공개적으로 접근 가능한 속성(Public Attribute)
     - 클래스 외부에서 자유롭게 값을 읽고 쓸 수 있으며, 다른 개발자가 이 변수를 직접 사용해도 괜찮음
     - `예시 : student.name = '김일'`과 같이 직접 접근하여 사용
   - _name
     - 내부용, 또는 비공개 속성(Private Attribute)
     - _를 붙여서 '외부에서 접근하지 마세요'와 같은 의미만 전달.
     - 이런 변수는 일반적으로 `@property` 데코레이터를 사용한 getter와 setter를 경유하여 간접적으로 접근하는것이 올바른 방법.

# JPA에서의 객체 생성 vs. python에서의 객체 생성
JPA(Java Persistence API)를 사용한 Java에서는 기본 생성자를 강제합니다 (springboot 에서도 적용됩니다.) 그런데 python에서는 매개변수 생성자를 '권장' 하는데, 이는 두 언어 간의 객체지향 패러다임과 데이터 관리 방식의 차이에 기인합니다.

1. Java(JPA)에서의 기본 생성자
   - JPA는 DB의 테이블과 (엔티티)클래스를 매핑하여 객체를 관리합니다(엔티티 클래스의 field가 DB 에서의 컬럼명이 된다고 했습니다.) 이 과정에서 JPA가 지가 직접 매개변수를 알 수는없기 때문에 매개변수가 없는 기본생성자를 먼저 호출하여 객체를 생성하고 DB에서의 컬럼값들을 하나씩 필드에 집어넣어줍니다. 이상을 이유로 JPA는 데이터 관리의 일관성과 효율성을 위해 기본생성자를 강제합니다.
```java
@Entity
@Data
public class Student {
    private String name;
    private int studentCode;
    
    //기본생성자가 강제됨
    public Student(){}
}

public class StudentMain {
    public static void main(String[] args){
        Student student1 = new Student();
        student1.setName('김일');
        student1.setStudentCode(2025001);
    }
}
```
이상의 코드라인처럼 일단 필드에 아무런 값이 없는 객체를 생성한 후에, DB상에서의 테이블에 있는 값들을 일치하는 컬럼명을 조회해서 집어넣어주는 과정을 거치기 때문에 기본생성자를 강제합니다.

2. python에서의 매개변수 생성자
   - 파이썬은 Java와 달리 동적 타이핑(Dynamic Typing) 언어라고 해서, 객체를 생성할 때 필수 속성들을 한 번에 초기화하는것을 권장합니다.
     1. 객체 무결성 보장 : init 메서드(생성자)에서 모든 필수 매개변수를 받으면, 객체가 생성되는 시점에 이미 완전한 상태를 갖게 됩니다.
     2. 명확한 코드 작성 : 클래스를 사용하는 사람이 어떤 정보가 필요한지를 명확하게 알 수 있습니다. Java처럼 순서대로 하는것도 아니고 keyword argument를 지원하기도 하니까요.

그리고 python과 db의 연동에 있어서 JPA처럼 값을 하나씩 집어넣기 보다는 ORM(Object-Relational Mapping) 라이브러리를 통해서 객체를 생성할 때 필요한 데이터를 직접 전달하는 방식으로 JPA와의 차이점이 있어 기본 생성자를 강제할 필요가 없습니다.

* 요약 : JPA는 DB와 연동하기 위한 기술적 제약으로 인해 기본 생성자를 명시해야한다.(매개변수 생성자를 하나라도 정의하는순간 기본생성자도 정의해야하니까) python은 객체의 완전성과 가독성을 중시하는 언어적 특성상 매개변수 생성자를 더 권장합니다.


```python
MENU = {
    '에스프레소': {'재료': {'물': 50, '커피': 18}, '가격': 1.5},
    '라떼': {'재료': {'물': 200, '우유': 150, '커피': 24}, '가격': 2.5},
    '카푸치노': {'재료': {'물': 250, '우유': 100, '커피': 24}, '가격': 3.0},
}
'''
에스프레소 / 라떼 / 카푸이노 50잔씩 만든다고 가정했을 때 필요한 커피 / 우유 / 물의 양
'''
coffee = 0
milk = 0
water = 0
for menu in MENU:
    for i in MENU[menu]['재료']:
        if i == '커피':
            coffee += MENU[menu]['재료'][i]
        elif i == '우유':
            milk += MENU[menu]['재료'][i]
        elif i == '물':
            water += MENU[menu]['재료'][i]
print(f'커피 : {coffee*50}')
print(f'우유 : {milk * 50}')
print(f'물 : {water * 50}')
'''
중첩적으로 이루어진 dictionary - json - 기타 collections 들이 합쳐진 데이터에서 내가 필요한 부분을 어떻게 추출할수 있는지

일반적으로 list의 경우 index를 이용하기때문에 반복문 쓰면 되지만 dictionary는 반복문을 돌리면 key가 나오게되고 , 그 key를 이용해야지만 value가 추출됩니다.

그리고 그 value를 이용해서 연산을하거나 로직을 작성해야합니다.

value가 또 dictionary거나 list 혹은 객체일 경우에는 좀 복잡해집니다.
'''
```


1과목 - 데이터 분석 기초기술 활용 / python
서답형 지난번과 동일
python

2과목

1 - 사용자로부터 전화번호를 입력받아, 특정 조건에 부합하는지 확인하고 전화번호의 중간 4자리를 출력하는 프로그램을 작성하시오. 전화번호는 - 를 포함하여 총 13자리 ( 010-1234-5678 )여야 한다.
지시사항:
1. 사용자로부터 전화번호를 입력받으시오.
2. 입력된 전화번호의 길이가 13자리가 아닐경우, "유효하지 않은 전화번호 형식입니다." 라고 출력
3. 전화번호가 13자리일 경우, 전화번호의 중간 4자리( 예: 1234 ) 를 추출하여 출력하시오.
4. 출력 시 f-string을 사용하시오.

실행 예
전화번호를 입력하시오 >>> 010-9876-5432 전화번호의 중간 4자리는 9876입니다.

전화번호를 입력하시오 >>> 010-123-4567 유효하지 않은 전화번호 형식입니다.



