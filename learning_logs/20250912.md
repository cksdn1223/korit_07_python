# 상속
형식 :
class 슈퍼클래스:
    본문
class 서브클래스(슈퍼클래스):
    본문
```python
class Person:
    def __init__(self, name):
        self.name = name

    def eat(self, food):
        print(f'{self.name}이(가) {food}를 먹습니다.')

class Student(Person):
    def __init__(self, name, school):
        super().__init__(name)
        self.school = school
    def study(self):
        print(f'{self.name}은(는) {self.school}에서 공부를 합니다.')

potter = Student("해리포터", '호그와트')
potter.eat("감자")
potter.study()
```
주목해야할점
1. Student 클래스에 정의되지 않은 메서드인 .eat()을 호출했다는 점.
2. Student 클래스의 생성자에서 확인되는 `super().__init__(name)`
    - 해당 부분은 슈퍼클래스의 생성자를 호출하는 방식
```python
    def eat(self, food):
        print(f'{self.school}에서', end=' ')
        super().eat(food)
```
이상과 같이 슈퍼클래스의 메서드인 .eat()을 override 하여 `재정의` 하는 것도 가능합니다.
기본적으로 `super().`을 베이스로 한다는것을 알 수 있습니다.

1. 서브 클래스의 __init__()
   - 서브 클래스는 슈퍼 클래스가 없으면 존재할 수 없습니다. 그래서 서브 클래스의 생성자를 구현할 때는 '반드시 슈퍼 클래스의 생성자를 먼저 호출' 하는 코드를 작성해야만 합니다.
   super(). 에서 -> 슈퍼클래스를 의미. 즉 Student의 생성자를 호출하려면 super().__init__(name)에 의해서 슈퍼 클래스인 Person의 생성자가 먼저 호출되면 '슈퍼 클래스의 객체가 생성' 됩니다. 이후에 슈퍼 클래스에서 생성된 인스턴스 변수인 name이 서브 클래스로 전달 되고, 이후에 서브 클래스에서 school인스턴스 변수를 선언 및 초기화하여 저장하면ㅅ ㅓ서브클래스의 인스턴스가 생성됩니다.
    생성자를 호출했다면 -> 객체가 생성되었다고 봐야하기 때문에 / 부모 클래스의 인스턴스와 자식 클래스의 인스턴스가 있다고 봐도 무방합니다. -> 그런데 별개의 객체냐고 물으면 그럴때도있고 아닐때도 있습니다.
2. 서브 클래스의 인스턴스 자료형
    슈퍼 클래스의 객체는 슈퍼 클래스의 인스턴스
    하지만 서브 클래스의 인스턴스는 서브 클래스의 인스턴스이면서 동시에 슈퍼 클래스의 인스턴스
    Student클래스의 객체는 Student의 인스턴스이면서 Person의 인스턴스
    Java를 기준으로 instanceof 연산자 역할을 하는 함수가 python에도 있는데 -> isinstance()
    형식:
    isinstance(객체명, 클래스명) -> boolean
```python
print(isinstance(potter, Person))   # 결과값 True
print(isinstance(potter, Student))  # 결과값 True
```


















